@page "/"
@page "/rom"
@using MediatR
@using System.Collections.Concurrent
@using U2pa.Electron.Link
@using U2pa.Electron.Link.Handlers.Rom

<PageTitle>Rom</PageTitle>

<p>
  <select class="form-control selectpicker" @bind="SelectedOperation">
    <option value="@RomOperation.Read">@RomOperation.Read</option>
    <option value="@RomOperation.Write">@RomOperation.Write</option>
  </select>
</p>
<p>Selected file: @SelectedFile</p>
<p role="status">Address count: @guiState.CurrentProgress</p>
<p role="status">State: @guiState.CurrentProgressBarShout</p>
<p>
  <select class="form-control selectpicker" @bind="SelectedRomType">
    <option>@uninitialized</option>
    @foreach (var item in RomTypes)
    {
      <option value="@item">@item</option>
    }
  </select>
</p>
<p>
  <progress value="@guiState.CurrentProgress" max="@guiState.MaxProgress"></progress>
</p>
<p>
  <button class="btn btn-primary" @onclick="SelectFile">Select file</button>
  <button class="btn btn-primary" @onclick="Execute">Execute</button>
  <button class="btn btn-primary" @onclick="Cancel">Cancel</button>
</p>

<p>
  <textarea class="logTextArea"  @bind="@Log" readonly cols="100"></textarea>
</p>

@inject IMediator mediator
@code {
    enum RomOperation
    {
        Read,
        Write,
    };

    const string uninitialized = "<choose>"; 
    private CancellationTokenSource? tokenSource;
    private GuiState guiState = null!;
    private bool currentlyWorking= false;
    private RomOperation SelectedOperation = RomOperation.Read;
    private string SelectedFile = uninitialized;
    private List<string> RomTypes = null!;
    private string SelectedRomType = null!;
    private string Log 
    {
        get
        {
            return String.Join(Environment.NewLine, 
              rawLog
              .Reverse()
              .Where(e => e.Item1 <= guiState.VerbosityLevel)
              .Select(e => e.Item2));
        }
        set
        {
        }
    }
    private ConcurrentBag<(int, string)> rawLog = new ConcurrentBag<(int, string)>();

    protected override async void OnInitialized()
    {
        guiState = new GuiState(Tick, (i, s) => 
        {
            rawLog.Add((i, s));
            Tick(null);
        });
        RomTypes = (await mediator.Send(new GetAllRomTypesQuery(), CancellationToken.None));
    }

    private void Tick(object? _)
    {
        InvokeAsync(StateHasChanged);
    }

    private async void SelectFile()
    {
        if (SelectedOperation == RomOperation.Read)
        {
            var file = (await ElectronNET.API.Electron.Dialog.ShowSaveDialogAsync(
              ElectronNET.API.Electron.WindowManager.BrowserWindows.First(),
              new ElectronNET.API.SaveDialogOptions()));

            if (file != null)
            {
                SelectedFile = file;
            }            
        }     
        else
        {
            var files = (await ElectronNET.API.Electron.Dialog.ShowOpenDialogAsync(
              ElectronNET.API.Electron.WindowManager.BrowserWindows.First(),
              new ElectronNET.API.Entities.OpenDialogOptions()));

            if (files.Length == 1)
            {
                SelectedFile = files[0];
            }            
        }

        Tick(null);
    }

    private bool EnsurePrerequisites()
    {
        if (currentlyWorking)
            return false;

        if(SelectedRomType == null || SelectedRomType == uninitialized)
        {
            ElectronNET.API.Electron.Dialog.ShowErrorBox("No Rom type selected", "Please select a valid Rom type");
            return false;
        }

        if(SelectedFile == null || SelectedFile == uninitialized)
        {
            ElectronNET.API.Electron.Dialog.ShowErrorBox("No file name choosen", "Please choose a filename");
            return false;
        }

        return true;
    }

    private async void Execute()
    {
        if (SelectedOperation == RomOperation.Read)
            await Read();
        else
            await Write();
    }

    private async Task Read()
    {
        if (!EnsurePrerequisites())
            return;

        currentlyWorking = true;

        guiState.Reset();
        var request = new ReadCommand(guiState, SelectedRomType, SelectedFile);
        tokenSource = new CancellationTokenSource();
        await mediator.Send(request, tokenSource.Token);
        tokenSource = null!;

        Tick(null); 
        currentlyWorking = false;
    }

    private async Task Write()
    {
        if (!EnsurePrerequisites())
            return;

        currentlyWorking = true;

        guiState.Reset();
        var request = new WriteCommand(guiState, SelectedRomType, SelectedFile);
        tokenSource = new CancellationTokenSource();
        await mediator.Send(request, tokenSource.Token);
        tokenSource = null!;

        Tick(null); 
        currentlyWorking = false;
    }

    private async void Cancel() => tokenSource?.Cancel();
}
